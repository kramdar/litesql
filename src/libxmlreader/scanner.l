/* Validating XML processor for litesql.dtd.
 * Generated 2009/10/22 00:39:48.
 *
 * This program was generated with the FleXML XML processor generator.
 * FleXML is Copyright (C) 1999-2005 Kristoffer Rose.  All rights reserved.
 * FleXML is Copyright (C) 2003-2006 Martin Quinson.  All rights reserved.
 * (Id: flexml.pl,v 1.62 2007/10/11 10:00:14 mquinson Exp).
 * 
 * There are two, intertwined parts to this program, part A and part B.
 *
 * Part A
 * ------
 * 
 * Some parts, here collectively called "Part A", are found in the 
 * FleXML package.  They are Copyright (C) 1999-2005 Kristoffer Rose
 * and Copyright (C) 2003-2006 Martin Quinson. All rights reserved.
 *
 * You can redistribute, use, perform, display and/or modify "Part A"
 * provided the following two conditions hold:
 *
 * 1. The program is distributed WITHOUT ANY WARRANTY from the author of
 *    FleXML; without even the implied warranty of MERCHANTABILITY or
 *    FITNESS FOR A PARTICULAR PURPOSE.
 *
 * 2. The program distribution conditions do not in any way affect the
 *    distribution conditions of the FleXML system used to generate this
 *    file or any version of FleXML derived from that system.
 *
 * Notice that these are explicit rights granted to you for files
 * generated by the FleXML system.  For your rights in connection with
 * the FleXML system itself please consult the GNU General Public License.
 * 
 * Part B
 * ------
 * 
 * The other parts, here collectively called "Part B", and which came 
 * from the DTD used by FleXML to generate this program, can be 
 * distributed (or not, as the case may be) under the terms of whoever
 * wrote them, provided these terms respect and obey the two conditions 
 * above under the heading "Part A".
 *
 * The author of and contributors to FleXML specifically disclaim
 * any copyright interest in "Part B", unless "Part B" was written 
 * by the author of or contributors to FleXML.
 * 
 */

%{

/* Version strings. */
const char rcs_flexml_skeleton[] =
 "$" "Id: skel,v 1.40 2007/10/11 09:57:24 mquinson Exp $";
const char rcs_flexml[] =
 "$" "Id: flexml.pl,v 1.62 2007/10/11 10:00:14 mquinson Exp $";

/* ANSI headers. */
#include <stdlib.h> /* for realloc() -- needed here when using flex 2.5.4 */
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>
#include <ctype.h>
     
#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32) || defined(__TOS_WIN__)
# ifndef __STRICT_ANSI__
#  include <io.h>
#  include <process.h>
# endif
#else
# include <unistd.h>
#endif
     
#ifndef FLEXML_INDEXSTACKSIZE
#define FLEXML_INDEXSTACKSIZE 1000
#endif

/* Generated definitions. */
#define FLEXML_yylineno
#ifndef FLEXML_BUFFERSTACKSIZE
#define FLEXML_BUFFERSTACKSIZE 100000
#endif
#define FLEXML_NEED_BUFFERLIT

/* XML processor api. */
#include "scanner-globals.hpp"


/* FleXML-provided data. */
int pcdata_ix;
extern char *bufferstack;
#define pcdata (bufferstack + pcdata_ix)
AT_type_name AX_type_name;
#define A_type_name (bufferstack + AX_type_name)
AT_option_name AX_option_name;
#define A_option_name (bufferstack + AX_option_name)
AT_relation_id AX_relation_id;
#define A_relation_id (bufferstack + AX_relation_id)
AT_relate_limit AX_relate_limit;
#define A_relate_limit AX_relate_limit
AT_object_name AX_object_name;
#define A_object_name (bufferstack + AX_object_name)
AT_check_oncreate AX_check_oncreate;
#define A_check_oncreate AX_check_oncreate
AT_interface_name AX_interface_name;
#define A_interface_name (bufferstack + AX_interface_name)
AT_field_indexed AX_field_indexed;
#define A_field_indexed AX_field_indexed
AT_database_name AX_database_name;
#define A_database_name (bufferstack + AX_database_name)
AT_database_namespace AX_database_namespace;
#define A_database_namespace (bufferstack + AX_database_namespace)
AT_check_function AX_check_function;
#define A_check_function (bufferstack + AX_check_function)
AT_method_name AX_method_name;
#define A_method_name (bufferstack + AX_method_name)
AT_represent_as AX_represent_as;
#define A_represent_as (bufferstack + AX_represent_as)
AT_field_default AX_field_default;
#define A_field_default (bufferstack + AX_field_default)
AT_method_returntype AX_method_returntype;
#define A_method_returntype (bufferstack + AX_method_returntype)
AT_param_type AX_param_type;
#define A_param_type (bufferstack + AX_param_type)
AT_represent_target AX_represent_target;
#define A_represent_target (bufferstack + AX_represent_target)
AT_indexfield_name AX_indexfield_name;
#define A_indexfield_name (bufferstack + AX_indexfield_name)
AT_check_param AX_check_param;
#define A_check_param (bufferstack + AX_check_param)
AT_option_value AX_option_value;
#define A_option_value (bufferstack + AX_option_value)
AT_value_name AX_value_name;
#define A_value_name (bufferstack + AX_value_name)
AT_relate_object AX_relate_object;
#define A_relate_object (bufferstack + AX_relate_object)
AT_database_include AX_database_include;
#define A_database_include (bufferstack + AX_database_include)
AT_store_backend AX_store_backend;
#define A_store_backend (bufferstack + AX_store_backend)
AT_object_temporary AX_object_temporary;
#define A_object_temporary AX_object_temporary
AT_check_onupdate AX_check_onupdate;
#define A_check_onupdate AX_check_onupdate
AT_field_name AX_field_name;
#define A_field_name (bufferstack + AX_field_name)
AT_relate_unique AX_relate_unique;
#define A_relate_unique AX_relate_unique
AT_object_inherits AX_object_inherits;
#define A_object_inherits (bufferstack + AX_object_inherits)
AT_value_value AX_value_value;
#define A_value_value (bufferstack + AX_value_value)
AT_method_const AX_method_const;
#define A_method_const AX_method_const
AT_relate_interface AX_relate_interface;
#define A_relate_interface (bufferstack + AX_relate_interface)
AT_store_as AX_store_as;
#define A_store_as (bufferstack + AX_store_as)
AT_option_backend AX_option_backend;
#define A_option_backend (bufferstack + AX_option_backend)
AT_param_name AX_param_name;
#define A_param_name (bufferstack + AX_param_name)
AT_index_unique AX_index_unique;
#define A_index_unique AX_index_unique
AT_field_type AX_field_type;
#define A_field_type (bufferstack + AX_field_type)
AT_check_ondelete AX_check_ondelete;
#define A_check_ondelete AX_check_ondelete
AT_include_file AX_include_file;
#define A_include_file (bufferstack + AX_include_file)
AT_relation_name AX_relation_name;
#define A_relation_name (bufferstack + AX_relation_name)
AT_check_onlink AX_check_onlink;
#define A_check_onlink AX_check_onlink
AT_relate_handle AX_relate_handle;
#define A_relate_handle (bufferstack + AX_relate_handle)
AT_check_onunlink AX_check_onunlink;
#define A_check_onunlink AX_check_onunlink
AT_field_unique AX_field_unique;
#define A_field_unique AX_field_unique
AT_implements_interface AX_implements_interface;
#define A_implements_interface (bufferstack + AX_implements_interface)

/* XML state. */
#ifdef FLEX_DEBUG
# define ENTER(state)	debug_enter(state,#state)
# define LEAVE		debug_leave()
# define SET(state)	debug_set(state,#state)
  static void debug_enter(int, const char*);
  static void debug_leave(void);
  static void debug_set(int, const char*);
#else
# define ENTER(state)	(yy_push_state(state))
# define LEAVE		(yy_pop_state())
# define SET(state)	BEGIN(state)
#endif

/* Generic actions. */
#define SKIP	/*skip*/
#define SUCCEED        CLEANUP; return 0

#define FAIL	return fail
static int fail(const char*, ...);

enum {flexml_max_err_msg_size = 512};
static char flexml_err_msg[flexml_max_err_msg_size];
const char * parse_err_msg()
{
    return flexml_err_msg;
}
static void reset_parse_err_msg()
{
    flexml_err_msg[0] = '\0';
}

/* Cleanup */
static void cleanup(void);
#define CLEANUP  cleanup()

/* Text buffer stack handling. */
char *bufferstack = NULL;
static int blimit = FLEXML_BUFFERSTACKSIZE;
static int bnext = 1;

static int *indexstack = NULL;
static int ilimit = FLEXML_INDEXSTACKSIZE;
static int inext = 1;

#define BUFFERSET(P)  (P = bnext)
#define BUFFERPUTC(C) (ck_blimit(), bufferstack[bnext++] = (C))
#define BUFFERDONE    (BUFFERPUTC('\0'))

#define BUFFERLITERAL(C, P) bufferliteral(C, &(P), yytext)

/* after this is called, there are at least 2 slots left in the stack */
static int ck_blimit()
{
     if (bnext >= blimit) {
	 blimit += FLEXML_BUFFERSTACKSIZE + 2;
	 {
	     char *temp = (char *) realloc(bufferstack, blimit);
	     assert(temp);
	     bufferstack = temp;
	 }
     }
     return 0;
}

/* after this is called, there are at least 2 slots left in the stack */
static int ck_ilimit()
{
     if (inext >= ilimit) {
	 ilimit += FLEXML_INDEXSTACKSIZE + 2;
	 {
	     int *temp = (int *) realloc(indexstack, ilimit);
	     assert(temp);
	     indexstack = temp;
	 }
     }
     return 0;
}

#ifdef FLEXML_NEED_BUFFERLIT
static void bufferliteral(char c, int* pp, const char* text)
{
  const char *s = (c ? strchr(text,c) : text-1), *e = strrchr(text,c);
  assert(s <= e); BUFFERSET(*pp);
  while (++s<e) {
    if (isspace(*s) && c) { BUFFERPUTC(' '); while (isspace(*s)) ++s; }
    else BUFFERPUTC(*s);
  }
  BUFFERDONE;
}
#endif

static void pushbuffer(int p)
{
    ck_ilimit();
    indexstack[inext++] = p;
    indexstack[inext++] = bnext;    
}

static int popbuffer(void)
{
    assert(inext >= 2);
    bnext = indexstack[--inext];
    return indexstack[--inext];
}

/* General internal entities are `unput' back onto the input stream... */
#define ENTITYTEXT(T) \
  { char *s = (T), *e = s+strlen(s);\
    while (--e >= s) { unput(*e); }}


%}

/* Flex standard options. */
%option stack
%option noyy_top_state
%option noinput
%option noreject
%option noyymore
%option noyywrap

/* Flex user-requested options. */
%option yylineno
%option nounput

/* XML character classes (currently restricted to ASCII). */

/* "Common syntactic structures." */
S		[ \t\n\r\f]+
s		[ \t\n\r\f]*

/* "Names and Tokens." */
NameChar	[A-Za-z0-9.:_-]
Name		[A-Za-z_:]{NameChar}*
Names 		{Name}({S}{Name})*
Nmtoken		({NameChar})+
Nmtokens 	{Nmtoken}({S}{Nmtoken})*

/* Miscellaneous. */
VersionNum	[a-zA-Z0-9_.:-]+
Eq		{s}"="{s}
Literal		\'[^'']*\'|\"[^""]*\"

/* Parser states (flex `exclusive start conditions'):
 *
 * PROLOG	the XML prolog of the document before <?xml...>
 * DOCTYPE	the XML prolog of the document after <?xml...>
 * EPILOG	after the root element
 * INCOMMENT	inside an XML comment <!--....-->
 * INPI		inside an XML PI <?...?>
 * VALUE1	inside a '...'-delimited literal
 * VALUE2	inside a "..."-delimited literal
 * CDATA	inside a <![CDATA[...] ]> section.
 * ROOT_<tag>	expect root element <tag>
 * AL_<tag>	inside the attribute list for <tag>
 * IN_<tag>	inside a <tag> with element contents (ready for end tag)
 * IMPOSSIBLE	dummy to permit disabling rules; must be last
 */
%x PROLOG DOCTYPE EPILOG INCOMMENT INPI VALUE1 VALUE2 CDATA
%x ROOT_database AL_database S_database S_database_1 S_database_2 E_database
%x ROOT_object AL_object S_object S_object_1 S_object_2 E_object
%x ROOT_interface AL_interface S_interface S_interface_1 S_interface_2 E_interface
%x ROOT_implements AL_implements E_implements
%x ROOT_check AL_check E_check
%x ROOT_type AL_type S_type S_type_1 S_type_2 S_type_3 S_type_4 S_type_5 S_type_6 S_type_7 S_type_8 S_type_9 S_type_10 S_type_11 E_type
%x ROOT_represent AL_represent E_represent
%x ROOT_store AL_store E_store
%x ROOT_include AL_include E_include
%x ROOT_option AL_option E_option
%x ROOT_field AL_field S_field S_field_1 S_field_2 S_field_3 S_field_4 S_field_5 E_field
%x ROOT_index AL_index S_index S_index_1 S_index_2 S_index_3 E_index
%x ROOT_indexfield AL_indexfield E_indexfield
%x ROOT_value AL_value E_value
%x ROOT_method AL_method S_method S_method_1 S_method_2 E_method
%x ROOT_param AL_param E_param
%x ROOT_relation AL_relation S_relation S_relation_1 S_relation_2 E_relation
%x ROOT_relate AL_relate E_relate
%x IMPOSSIBLE

%{
/* State names. */
const char* *statenames=NULL;
%}

%%

 /* Bypass Flex's default INITIAL state and begin by parsing the XML prolog. */
 SET(PROLOG);
 reset_parse_err_msg();
 bufferstack = (char *) malloc(FLEXML_BUFFERSTACKSIZE);
 assert(bufferstack);
 #ifdef FLEX_DEBUG
 {
     int i;
     for (i = 0; i < blimit; i++) {
         bufferstack[i] = '\377';
     }
 }
 #endif
 bufferstack[0] = '\0';
 indexstack = (int *) malloc(FLEXML_INDEXSTACKSIZE * sizeof(int));
 assert(indexstack);
 indexstack[0] = 0;

  /* FleXML_init */
  bnext = inext = 1;
  if(!statenames) {statenames= (const char **)calloc(IMPOSSIBLE,sizeof(char*));
  statenames[PROLOG] = NULL;
  statenames[DOCTYPE] = NULL;
  statenames[EPILOG] = NULL;
  statenames[INCOMMENT] = NULL;
  statenames[INPI] = NULL;
  statenames[VALUE1] = NULL;
  statenames[VALUE2] = NULL;
  statenames[CDATA] = NULL;
  statenames[ROOT_database] = NULL;
  statenames[AL_database] = NULL;
  statenames[S_database] = "database";
  statenames[S_database_1] = "database";
  statenames[S_database_2] = "database";
  statenames[E_database] = "database";
  statenames[ROOT_object] = NULL;
  statenames[AL_object] = NULL;
  statenames[S_object] = "object";
  statenames[S_object_1] = "object";
  statenames[S_object_2] = "object";
  statenames[E_object] = "object";
  statenames[ROOT_interface] = NULL;
  statenames[AL_interface] = NULL;
  statenames[S_interface] = "interface";
  statenames[S_interface_1] = "interface";
  statenames[S_interface_2] = "interface";
  statenames[E_interface] = "interface";
  statenames[ROOT_implements] = NULL;
  statenames[AL_implements] = NULL;
  statenames[E_implements] = "implements";
  statenames[ROOT_check] = NULL;
  statenames[AL_check] = NULL;
  statenames[E_check] = "check";
  statenames[ROOT_type] = NULL;
  statenames[AL_type] = NULL;
  statenames[S_type] = "type";
  statenames[S_type_1] = "type";
  statenames[S_type_2] = "type";
  statenames[S_type_3] = "type";
  statenames[S_type_4] = "type";
  statenames[S_type_5] = "type";
  statenames[S_type_6] = "type";
  statenames[S_type_7] = "type";
  statenames[S_type_8] = "type";
  statenames[S_type_9] = "type";
  statenames[S_type_10] = "type";
  statenames[S_type_11] = "type";
  statenames[E_type] = "type";
  statenames[ROOT_represent] = NULL;
  statenames[AL_represent] = NULL;
  statenames[E_represent] = "represent";
  statenames[ROOT_store] = NULL;
  statenames[AL_store] = NULL;
  statenames[E_store] = "store";
  statenames[ROOT_include] = NULL;
  statenames[AL_include] = NULL;
  statenames[E_include] = "include";
  statenames[ROOT_option] = NULL;
  statenames[AL_option] = NULL;
  statenames[E_option] = "option";
  statenames[ROOT_field] = NULL;
  statenames[AL_field] = NULL;
  statenames[S_field] = "field";
  statenames[S_field_1] = "field";
  statenames[S_field_2] = "field";
  statenames[S_field_3] = "field";
  statenames[S_field_4] = "field";
  statenames[S_field_5] = "field";
  statenames[E_field] = "field";
  statenames[ROOT_index] = NULL;
  statenames[AL_index] = NULL;
  statenames[S_index] = "index";
  statenames[S_index_1] = "index";
  statenames[S_index_2] = "index";
  statenames[S_index_3] = "index";
  statenames[E_index] = "index";
  statenames[ROOT_indexfield] = NULL;
  statenames[AL_indexfield] = NULL;
  statenames[E_indexfield] = "indexfield";
  statenames[ROOT_value] = NULL;
  statenames[AL_value] = NULL;
  statenames[E_value] = "value";
  statenames[ROOT_method] = NULL;
  statenames[AL_method] = NULL;
  statenames[S_method] = "method";
  statenames[S_method_1] = "method";
  statenames[S_method_2] = "method";
  statenames[E_method] = "method";
  statenames[ROOT_param] = NULL;
  statenames[AL_param] = NULL;
  statenames[E_param] = "param";
  statenames[ROOT_relation] = NULL;
  statenames[AL_relation] = NULL;
  statenames[S_relation] = "relation";
  statenames[S_relation_1] = "relation";
  statenames[S_relation_2] = "relation";
  statenames[E_relation] = "relation";
  statenames[ROOT_relate] = NULL;
  statenames[AL_relate] = NULL;
  statenames[E_relate] = "relate";
  }

 /* COMMENTS and PIs: handled uniformly for efficiency. */

<ROOT_database,AL_database,S_database,S_database_1,S_database_2,E_database,ROOT_object,AL_object,S_object,S_object_1,S_object_2,E_object,ROOT_interface,AL_interface,S_interface,S_interface_1,S_interface_2,E_interface,ROOT_implements,AL_implements,E_implements,ROOT_check,AL_check,E_check,ROOT_type,AL_type,S_type,S_type_1,S_type_2,S_type_3,S_type_4,S_type_5,S_type_6,S_type_7,S_type_8,S_type_9,S_type_10,S_type_11,E_type,ROOT_represent,AL_represent,E_represent,ROOT_store,AL_store,E_store,ROOT_include,AL_include,E_include,ROOT_option,AL_option,E_option,ROOT_field,AL_field,S_field,S_field_1,S_field_2,S_field_3,S_field_4,S_field_5,E_field,ROOT_index,AL_index,S_index,S_index_1,S_index_2,S_index_3,E_index,ROOT_indexfield,AL_indexfield,E_indexfield,ROOT_value,AL_value,E_value,ROOT_method,AL_method,S_method,S_method_1,S_method_2,E_method,ROOT_param,AL_param,E_param,ROOT_relation,AL_relation,S_relation,S_relation_1,S_relation_2,E_relation,ROOT_relate,AL_relate,E_relate,PROLOG,DOCTYPE,EPILOG>{
 "<!--" ENTER(INCOMMENT);
 "<?" ENTER(INPI);
}
<INCOMMENT>{
 "-->"		LEAVE;
 "--"		|
 .		|
 \n		SKIP;
 <<EOF>>	FAIL("EOF in comment.");
}
<INPI>{
 "?>"		LEAVE;
 .		|
 \n		SKIP;
 <<EOF>>	FAIL("EOF in PI (processing instruction).");
}

 /* SPACES: skipped uniformly */

<ROOT_database,AL_database,S_database,S_database_1,S_database_2,E_database,ROOT_object,AL_object,S_object,S_object_1,S_object_2,E_object,ROOT_interface,AL_interface,S_interface,S_interface_1,S_interface_2,E_interface,ROOT_implements,AL_implements,E_implements,ROOT_check,AL_check,E_check,ROOT_type,AL_type,S_type,S_type_1,S_type_2,S_type_3,S_type_4,S_type_5,S_type_6,S_type_7,S_type_8,S_type_9,S_type_10,S_type_11,E_type,ROOT_represent,AL_represent,E_represent,ROOT_store,AL_store,E_store,ROOT_include,AL_include,E_include,ROOT_option,AL_option,E_option,ROOT_field,AL_field,S_field,S_field_1,S_field_2,S_field_3,S_field_4,S_field_5,E_field,ROOT_index,AL_index,S_index,S_index_1,S_index_2,S_index_3,E_index,ROOT_indexfield,AL_indexfield,E_indexfield,ROOT_value,AL_value,E_value,ROOT_method,AL_method,S_method,S_method_1,S_method_2,E_method,ROOT_param,AL_param,E_param,ROOT_relation,AL_relation,S_relation,S_relation_1,S_relation_2,E_relation,ROOT_relate,AL_relate,E_relate,PROLOG,DOCTYPE,EPILOG>{S} SKIP;

 /* PROLOG: determine root element and process it. */

<PROLOG>{
 "<?xml"({S}version{Eq}(\'{VersionNum}\'|\"{VersionNum}\"))?({S}encoding{Eq}(\'[^']*\'|\"[^"]*\"))?"?>" SET(DOCTYPE); 
 "<?xml"[^>]*">" FAIL("Bad declaration %s.",yytext);
}

<PROLOG,DOCTYPE>{
 "<!DOCTYPE"{S}"object"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_object);
 "<!DOCTYPE"{S}"include"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_include);
 "<!DOCTYPE"{S}"represent"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_represent);
 "<!DOCTYPE"{S}"check"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_check);
 "<!DOCTYPE"{S}"interface"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_interface);
 "<!DOCTYPE"{S}"method"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_method);
 "<!DOCTYPE"{S}"indexfield"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_indexfield);
 "<!DOCTYPE"{S}"option"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_option);
 "<!DOCTYPE"{S}"param"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_param);
 "<!DOCTYPE"{S}"field"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_field);
 "<!DOCTYPE"{S}"implements"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_implements);
 "<!DOCTYPE"{S}"store"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_store);
 "<!DOCTYPE"{S}"relate"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_relate);
 "<!DOCTYPE"{S}"value"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_value);
 "<!DOCTYPE"{S}"database"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_database);
 "<!DOCTYPE"{S}"index"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_index);
 "<!DOCTYPE"{S}"relation"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_relation);
 "<!DOCTYPE"{S}"type"{S}SYSTEM{S}("'litesql.dtd'"|"\"litesql.dtd\""){s}">" SET(ROOT_type);
 "<!"[^>-][^>]*">" FAIL("Bad declaration %s.",yytext);
 . 		FAIL("Unexpected character `%c' in prolog.", yytext[0]);
 <<EOF>> 	FAIL("EOF in prolog.");
}

 /* RULES DERIVED FROM DTD. */

 /* <!-- litesql XML database definition syntax -->
  * <!-- Top level database information 
  *      Defines a collection of objects and relations in a database.
  *     
  *      name
  *         Name of the database.
  *      namespace
  *         All generated code is placed into a namespace to avoid
  *         name collisions with other sources.
  *      
  *      include
  *         The file to be included from the generated code, 
  *         in target-independent format, that is, no file extension. 
  * -->  */

 /*           name ID #REQUIRED
  *           namespace NMTOKEN #REQUIRED
  *           include NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_type_4,S_database,S_interface_2,S_index_1,E_method,S_index_3,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_type_2,S_field_4,S_type_11,S_database_1,S_type_5,S_method_2,S_object_1,S_interface,S_field_5,S_object_2,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<database"{s} FAIL("Starting tag <database> is not allowed here.");

<ROOT_database>"<database"{s} {
  AX_database_name = 0;
  AX_database_namespace = 0;
  AX_database_include = 0;
  ENTER(AL_database); pushbuffer(0);
  }

<AL_database>{
 "name"{Eq}'{Name}' BUFFERLITERAL('\'',AX_database_name);
 "name"{Eq}\"{Name}\" BUFFERLITERAL('"',AX_database_name);

 "namespace"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_database_namespace);
 "namespace"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_database_namespace);

 "include"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_database_include);
 "include"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_database_include);

 ">" {
  if (!AX_database_name) FAIL("Required attribute `name' not set for `database' element.");
  if (!AX_database_namespace) FAIL("Required attribute `namespace' not set for `database' element.");
  LEAVE; STag_database();pcdata_ix = 0; ENTER(S_database);
 }
 "/>" FAIL("`database' element cannot be empty.");
 .       FAIL("Unexpected character `%c' in attribute list of database element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `database' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `database' element.");
}

<S_database_2,E_database>{
 "</database"{s}">" {
  LEAVE;
  ETag_database();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_database: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</database>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</database>' expected.",yytext[0]);
 <<EOF>> {
yypop_buffer_state();
if (!xml::posStack.empty()) {xml::Position p = *xml::posStack.begin(); yylineno = p.line; xml::currentFile = p.file; xml::posStack.pop_front(); } 
if (!YY_CURRENT_BUFFER) FAIL("Premature EOF: `</database>' expected.");}
}

 /* <!-- Persistent object (class of objects) 
  *     
  *      Defines a persistent object that can be stored in a database. 
  *      
  *      
  *      temporary
  *      
  *         if true, all the tables associated with the object
  *         are created (and flagged as temporary) when a database 
  *         connection is opened. When the connection is closed, the 
  *         tables are dropped. 
  *        
  *      name
  *         Name of the class of objects.
  *      inherits
  *         Defines an inheritance relationship between objects. The object that
  *         is being defined inherits all the fields, relations, interfaces and
  *         methods from the parent.
  * -->  */

 /*           temporary (true|false) 'false'
  *           name ID #REQUIRED
  *           inherits NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<object"{s} FAIL("Starting tag <object> is not allowed here.");

<ROOT_object,S_database_1,S_database,S_database_2>"<object"{s} {
  AX_object_temporary = A_object_temporary_false;
  AX_object_name = 0;
  AX_object_inherits = 0;
  ENTER(AL_object); pushbuffer(0);
  }

<AL_object>{
 "temporary"{Eq}"'true'" |
 "temporary"{Eq}"\"true\"" A_object_temporary = A_object_temporary_true;
 "temporary"{Eq}"'false'" |
 "temporary"{Eq}"\"false\"" A_object_temporary = A_object_temporary_false;

 "name"{Eq}'{Name}' BUFFERLITERAL('\'',AX_object_name);
 "name"{Eq}\"{Name}\" BUFFERLITERAL('"',AX_object_name);

 "inherits"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_object_inherits);
 "inherits"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_object_inherits);

 ">" {
  if (!AX_object_name) FAIL("Required attribute `name' not set for `object' element.");
  LEAVE; STag_object();pcdata_ix = 0; ENTER(S_object);
 }
 "/>" {
  if (!AX_object_name) FAIL("Required attribute `name' not set for `object' element.");
  LEAVE; STag_object(); pcdata_ix = 0; ETag_object(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_object: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of object element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `object' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `object' element.");
}

<E_object,S_object,S_object_2>{
 "</object"{s}">" {
  LEAVE;
  ETag_object();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_object: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</object>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</object>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</object>' expected.");
}

 /* <!-- Interface 
  *      Defines an interface of methods (and relations). 
  *      
  *      
  *      name
  *      
  *         Name of the interface.
  * -->  */

 /*           name ID #REQUIRED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<interface"{s} FAIL("Starting tag <interface> is not allowed here.");

<ROOT_interface>"<interface"{s} {
  AX_interface_name = 0;
  ENTER(AL_interface); pushbuffer(0);
  }

<AL_interface>{
 "name"{Eq}'{Name}' BUFFERLITERAL('\'',AX_interface_name);
 "name"{Eq}\"{Name}\" BUFFERLITERAL('"',AX_interface_name);

 ">" {
  if (!AX_interface_name) FAIL("Required attribute `name' not set for `interface' element.");
  LEAVE; STag_interface();pcdata_ix = 0; ENTER(S_interface);
 }
 "/>" {
  if (!AX_interface_name) FAIL("Required attribute `name' not set for `interface' element.");
  LEAVE; STag_interface(); pcdata_ix = 0; ETag_interface(); popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_interface: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of interface element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `interface' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `interface' element.");
}

<E_interface,S_interface_2,S_interface>{
 "</interface"{s}">" {
  LEAVE;
  ETag_interface();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_interface: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</interface>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</interface>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</interface>' expected.");
}

 /* <!-- Interface implementation
  *      Indicates that the object implements an interface.
  *      The object will inherit methods and relations of the interface.
  *      interface
  *      
  *         Name of the interface.
  * -->  */

 /*           interface NMTOKEN #REQUIRED>  */

<E_relation,S_method_1,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_method_2,S_field_5,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<implements"{s} FAIL("Starting tag <implements> is not allowed here.");

<ROOT_implements,S_object_1,S_object,S_object_2>"<implements"{s} {
  AX_implements_interface = 0;
  ENTER(AL_implements); pushbuffer(0);
  }

<AL_implements>{
 "interface"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_implements_interface);
 "interface"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_implements_interface);

 ">" {
  if (!AX_implements_interface) FAIL("Required attribute `interface' not set for `implements' element.");
  LEAVE; STag_implements();pcdata_ix = 0; ENTER(E_implements);
 }
 "/>" {
  if (!AX_implements_interface) FAIL("Required attribute `interface' not set for `implements' element.");
  LEAVE; STag_implements(); pcdata_ix = 0; ETag_implements(); popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_implements: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of implements element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `implements' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `implements' element.");
}

<E_implements>{
 "</implements"{s}">" {
  LEAVE;
  ETag_implements();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_implements: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</implements>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</implements>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</implements>' expected.");
}

 /* <!-- Consistency check 
  *      An assertion which is verified upon specified triggers.
  *      It can be defined for data types, specific fields, relation operations
  *      and object-wide operations.
  *      If no triggers are specified for the consistency check,
  *      it is executed for every operation.
  *      oncreate
  *         If true, the check function is executed when the object is created.
  *         Can only be used with object-wide checks.
  *      
  *      ondelete
  *         If true, the check function is executed when the object is deleted.
  *         Can only be used with object-wise checks.
  *      onupdate
  *         
  *         If true, the check function is executed when data is being updated.
  *      
  *      onlink
  *         If true, the check function is executed upon linkage.
  *         Can only be used with relation operations.
  *      onunlink
  *         If true, the check function is executed upon unlinkage.
  *         Can only be used with relation operations.
  *     
  *      function
  *         Name of the check function.
  *      
  *      param
  *         Additional parameter supplied to the check function.
  * -->  */

 /*           oncreate (true|false) 'false'
  *           ondelete (true|false) 'false'
  *           onupdate (true|false) 'false'
  *           onlink   (true|false) 'false'
  *           onunlink (true|false) 'false'
  *           function NMTOKEN #REQUIRED
  *           param    CDATA   #IMPLIED>  */

<E_relation,S_method_1,E_database,S_database,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_relation_2,S_type_2,S_database_1,S_type_5,S_interface,S_method_2,S_type_8,S_index,S_method,E_interface,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_relation,E_index>"<check"{s} FAIL("Starting tag <check> is not allowed here.");

<ROOT_check,S_field_4,S_type_11,S_object_1,S_object,S_field_5,S_object_2,S_type_9,S_type_7,S_type_4,S_field,S_type_10,S_type_6,S_field_1,S_type,S_field_3,S_type_3,S_type_1>"<check"{s} {
  AX_check_oncreate = A_check_oncreate_false;
  AX_check_ondelete = A_check_ondelete_false;
  AX_check_onupdate = A_check_onupdate_false;
  AX_check_onlink = A_check_onlink_false;
  AX_check_onunlink = A_check_onunlink_false;
  AX_check_function = 0;
  AX_check_param = 0;
  ENTER(AL_check); pushbuffer(0);
  }

<AL_check>{
 "oncreate"{Eq}"'true'" |
 "oncreate"{Eq}"\"true\"" A_check_oncreate = A_check_oncreate_true;
 "oncreate"{Eq}"'false'" |
 "oncreate"{Eq}"\"false\"" A_check_oncreate = A_check_oncreate_false;

 "ondelete"{Eq}"'true'" |
 "ondelete"{Eq}"\"true\"" A_check_ondelete = A_check_ondelete_true;
 "ondelete"{Eq}"'false'" |
 "ondelete"{Eq}"\"false\"" A_check_ondelete = A_check_ondelete_false;

 "onupdate"{Eq}"'true'" |
 "onupdate"{Eq}"\"true\"" A_check_onupdate = A_check_onupdate_true;
 "onupdate"{Eq}"'false'" |
 "onupdate"{Eq}"\"false\"" A_check_onupdate = A_check_onupdate_false;

 "onlink"{Eq}"'true'" |
 "onlink"{Eq}"\"true\"" A_check_onlink = A_check_onlink_true;
 "onlink"{Eq}"'false'" |
 "onlink"{Eq}"\"false\"" A_check_onlink = A_check_onlink_false;

 "onunlink"{Eq}"'true'" |
 "onunlink"{Eq}"\"true\"" A_check_onunlink = A_check_onunlink_true;
 "onunlink"{Eq}"'false'" |
 "onunlink"{Eq}"\"false\"" A_check_onunlink = A_check_onunlink_false;

 "function"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_check_function);
 "function"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_check_function);

 "param"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_check_param);
 "param"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_check_param);

 ">" {
  if (!AX_check_function) FAIL("Required attribute `function' not set for `check' element.");
  LEAVE; STag_check();pcdata_ix = 0; ENTER(E_check);
 }
 "/>" {
  if (!AX_check_function) FAIL("Required attribute `function' not set for `check' element.");
  LEAVE; STag_check(); pcdata_ix = 0; ETag_check(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_type_11: case S_type_9: case S_type_7: case S_type_4: case S_type_10: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_11); break;
   case ROOT_check: SET(EPILOG); break;
   case S_field_4: case S_field_5: case S_field: case S_field_1: case S_field_3: SET(S_field_5); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of check element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `check' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `check' element.");
}

<E_check>{
 "</check"{s}">" {
  LEAVE;
  ETag_check();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_type_11: case S_type_9: case S_type_7: case S_type_4: case S_type_10: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_11); break;
   case ROOT_check: SET(EPILOG); break;
   case S_field_4: case S_field_5: case S_field: case S_field_1: case S_field_3: SET(S_field_5); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</check>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</check>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</check>' expected.");
}

 /* <!-- Custom data type 
  *      Defines a data type and the means of representing and storing it. 
  *      
  *      
  *      name 
  *      
  *         Name of the data type.
  * -->  */

 /*           name NMTOKEN #REQUIRED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<type"{s} FAIL("Starting tag <type> is not allowed here.");

<ROOT_type,S_database_1,S_database,S_database_2>"<type"{s} {
  AX_type_name = 0;
  ENTER(AL_type); pushbuffer(0);
  }

<AL_type>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_type_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_type_name);

 ">" {
  if (!AX_type_name) FAIL("Required attribute `name' not set for `type' element.");
  LEAVE; STag_type();pcdata_ix = 0; ENTER(S_type);
 }
 "/>" {
  if (!AX_type_name) FAIL("Required attribute `name' not set for `type' element.");
  LEAVE; STag_type(); pcdata_ix = 0; ETag_type(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_type: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of type element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `type' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `type' element.");
}

<S_type_11,S_type,S_type_9,E_type,S_type_7,S_type_4,S_type_3,S_type_1,S_type_6>{
 "</type"{s}">" {
  LEAVE;
  ETag_type();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_type: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</type>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</type>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</type>' expected.");
}

 /* <!-- Custom data type representation 
  *      Defines how data type is represented in a target language. 
  *      
  *      
  *      as 
  *         
  *         Target language data type.
  *      
  *      target
  *         Target language name. If not specified, this representation of
  *         data is the default for all targets. 
  * -->  */

 /*           as      CDATA   #REQUIRED
  *           target  NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_field_3,S_relation_2,S_field_4,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_relation,S_type_1,E_index>"<represent"{s} FAIL("Starting tag <represent> is not allowed here.");

<ROOT_represent,S_type_2,S_type,S_type_3>"<represent"{s} {
  AX_represent_as = 0;
  AX_represent_target = 0;
  ENTER(AL_represent); pushbuffer(0);
  }

<AL_represent>{
 "as"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_represent_as);
 "as"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_represent_as);

 "target"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_represent_target);
 "target"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_represent_target);

 ">" {
  if (!AX_represent_as) FAIL("Required attribute `as' not set for `represent' element.");
  LEAVE; STag_represent();pcdata_ix = 0; ENTER(E_represent);
 }
 "/>" {
  if (!AX_represent_as) FAIL("Required attribute `as' not set for `represent' element.");
  LEAVE; STag_represent(); pcdata_ix = 0; ETag_represent(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_type_2: case S_type: case S_type_3: SET(S_type_3); break;
   case ROOT_represent: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of represent element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `represent' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `represent' element.");
}

<E_represent>{
 "</represent"{s}">" {
  LEAVE;
  ETag_represent();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_type_2: case S_type: case S_type_3: SET(S_type_3); break;
   case ROOT_represent: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</represent>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</represent>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</represent>' expected.");
}

 /* <!-- Custom data type storage definition 
  *      Defines how data type is stored in a database
  *      
  *      
  *      as
  *         
  *         SQL data type.
  *         
  *      
  *      backend
  *      
  *         Database backend name. If not specified, data will be stored
  *         using this definition by default. 
  * -->  */

 /*           as      CDATA   #REQUIRED
  *           backend NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_relation,E_index>"<store"{s} FAIL("Starting tag <store> is not allowed here.");

<ROOT_store,S_type_5,S_type_6,S_type,S_type_3,S_type_1>"<store"{s} {
  AX_store_as = 0;
  AX_store_backend = 0;
  ENTER(AL_store); pushbuffer(0);
  }

<AL_store>{
 "as"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_store_as);
 "as"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_store_as);

 "backend"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_store_backend);
 "backend"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_store_backend);

 ">" {
  if (!AX_store_as) FAIL("Required attribute `as' not set for `store' element.");
  LEAVE; STag_store();pcdata_ix = 0; ENTER(E_store);
 }
 "/>" {
  if (!AX_store_as) FAIL("Required attribute `as' not set for `store' element.");
  LEAVE; STag_store(); pcdata_ix = 0; ETag_store(); popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_store: SET(EPILOG); break;
   case S_type_5: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_6); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of store element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `store' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `store' element.");
}

<E_store>{
 "</store"{s}">" {
  LEAVE;
  ETag_store();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case ROOT_store: SET(EPILOG); break;
   case S_type_5: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_6); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</store>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</store>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</store>' expected.");
}

 /* <!-- Include another litesql definition 
  *      The file being included should not contain normal XML preludes
  *      <?xml ... ?>, only the tags that one wishes to replace the include
  *      tag with.
  *      file
  *         Name of the file to be included.
  * -->  */

 /*           file CDATA #REQUIRED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<include"{s} FAIL("Starting tag <include> is not allowed here.");

<ROOT_include,S_database_1,S_database,S_database_2>"<include"{s} {
  AX_include_file = 0;
  ENTER(AL_include); pushbuffer(0);
  }

<AL_include>{
 "file"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_include_file);
 "file"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_include_file);

 ">" {
  if (!AX_include_file) FAIL("Required attribute `file' not set for `include' element.");
  LEAVE; STag_include();pcdata_ix = 0; ENTER(E_include);
 }
 "/>" {
  if (!AX_include_file) FAIL("Required attribute `file' not set for `include' element.");
  LEAVE; STag_include(); pcdata_ix = 0; ETag_include(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_include: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of include element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `include' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `include' element.");
}

<E_include>{
 "</include"{s}">" {
  LEAVE;
  ETag_include();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_include: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</include>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</include>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</include>' expected.");
}

 /* <!-- Backend (specific) option 
  *      This tag can be used to set backend specific options
  *      either globally or for a single table.
  *      
  *      
  *      name
  *      
  *         Name of the option.
  *         
  *       
  *      value
  *      
  *         Value of the option.
  *         
  *      
  *      backend
  *      
  *         Name of the backend.
  * -->  */

 /*           name    CDATA #REQUIRED
  *           value   CDATA #REQUIRED
  *           backend NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,E_database,S_type_9,S_type_7,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_field_4,S_type_2,S_type_11,S_type_5,S_interface,S_method_2,S_field_5,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_type_1,E_index>"<option"{s} FAIL("Starting tag <option> is not allowed here.");

<ROOT_option,S_database_1,S_object_1,S_object,S_object_2,S_database,S_database_2,S_relation_1,S_relation_2,S_relation>"<option"{s} {
  AX_option_name = 0;
  AX_option_value = 0;
  AX_option_backend = 0;
  ENTER(AL_option); pushbuffer(0);
  }

<AL_option>{
 "name"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_option_name);
 "name"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_option_name);

 "value"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_option_value);
 "value"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_option_value);

 "backend"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_option_backend);
 "backend"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_option_backend);

 ">" {
  if (!AX_option_name) FAIL("Required attribute `name' not set for `option' element.");
  if (!AX_option_value) FAIL("Required attribute `value' not set for `option' element.");
  LEAVE; STag_option();pcdata_ix = 0; ENTER(E_option);
 }
 "/>" {
  if (!AX_option_name) FAIL("Required attribute `name' not set for `option' element.");
  if (!AX_option_value) FAIL("Required attribute `value' not set for `option' element.");
  LEAVE; STag_option(); pcdata_ix = 0; ETag_option(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_option: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of option element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `option' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `option' element.");
}

<E_option>{
 "</option"{s}">" {
  LEAVE;
  ETag_option();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_option: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</option>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</option>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</option>' expected.");
}

 /* <!-- Field definition 
  *      Defines a field that holds a single value of an object or a relation.
  *      
  *      
  *      name
  *         
  *         Name of the field.
  *         
  *      
  *      type
  *      
  *         Type of the field (litesql type name).
  *         
  *      
  *      default
  *      
  *         Default value of the field.  When used in a relation, the fields with
  *         default values must be placed last.
  *         
  *      indexed
  *         If true, the table is indexed by this field (an index is created).
  *         See index-tag for multi-field indices.
  *      unique
  *         
  *         If true, an uniqueness constraint is added to the table.    
  * -->  */

 /*           name NMTOKEN #REQUIRED
  *           type NMTOKEN #REQUIRED
  *           default CDATA #IMPLIED
  *           indexed (true|false) "false"
  *           unique (true|false) "false">  */

<E_relation,S_method_1,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_method_2,S_field_5,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_type_1,E_index>"<field"{s} FAIL("Starting tag <field> is not allowed here.");

<ROOT_field,S_object_1,S_object,S_object_2,S_relation_1,S_relation_2,S_relation>"<field"{s} {
  AX_field_name = 0;
  AX_field_type = 0;
  AX_field_default = 0;
  AX_field_indexed = A_field_indexed_false;
  AX_field_unique = A_field_unique_false;
  ENTER(AL_field); pushbuffer(0);
  }

<AL_field>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_field_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_field_name);

 "type"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_field_type);
 "type"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_field_type);

 "default"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_field_default);
 "default"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_field_default);

 "indexed"{Eq}"'true'" |
 "indexed"{Eq}"\"true\"" A_field_indexed = A_field_indexed_true;
 "indexed"{Eq}"'false'" |
 "indexed"{Eq}"\"false\"" A_field_indexed = A_field_indexed_false;

 "unique"{Eq}"'true'" |
 "unique"{Eq}"\"true\"" A_field_unique = A_field_unique_true;
 "unique"{Eq}"'false'" |
 "unique"{Eq}"\"false\"" A_field_unique = A_field_unique_false;

 ">" {
  if (!AX_field_name) FAIL("Required attribute `name' not set for `field' element.");
  if (!AX_field_type) FAIL("Required attribute `type' not set for `field' element.");
  LEAVE; STag_field();pcdata_ix = 0; ENTER(S_field);
 }
 "/>" {
  if (!AX_field_name) FAIL("Required attribute `name' not set for `field' element.");
  if (!AX_field_type) FAIL("Required attribute `type' not set for `field' element.");
  LEAVE; STag_field(); pcdata_ix = 0; ETag_field(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case ROOT_field: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of field element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `field' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `field' element.");
}

<E_field,S_field_1,S_field_5,S_field_3,S_field>{
 "</field"{s}">" {
  LEAVE;
  ETag_field();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case ROOT_field: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</field>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</field>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</field>' expected.");
}

 /* <!-- Index definition 
  *      A multi-field index for a table of an object or a relation.
  *  
  *      unique
  *         If true, the combination of the fields' values is unique.
  * -->  */

 /*           unique (true|false) "false">  */

<E_relation,S_method_1,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_method_2,S_field_5,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_type_1,E_index>"<index"{s} FAIL("Starting tag <index> is not allowed here.");

<ROOT_index,S_object_1,S_object,S_object_2,S_relation_1,S_relation_2,S_relation>"<index"{s} {
  AX_index_unique = A_index_unique_false;
  ENTER(AL_index); pushbuffer(0);
  }

<AL_index>{
 "unique"{Eq}"'true'" |
 "unique"{Eq}"\"true\"" A_index_unique = A_index_unique_true;
 "unique"{Eq}"'false'" |
 "unique"{Eq}"\"false\"" A_index_unique = A_index_unique_false;

 ">" {
  LEAVE; STag_index();pcdata_ix = 0; ENTER(S_index);
 }
 "/>" FAIL("`index' element cannot be empty.");
 .       FAIL("Unexpected character `%c' in attribute list of index element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `index' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `index' element.");
}

<S_index_3,E_index>{
 "</index"{s}">" {
  LEAVE;
  ETag_index();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case ROOT_index: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</index>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</index>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</index>' expected.");
}

 /* <!-- Indexed field 
  *      A field that is included in an index.
  *      
  *      
  *      name
  *         
  *         Name of the field.
  * -->  */

 /*           name NMTOKEN #REQUIRED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_type_3,S_relation,S_type_1,E_index>"<indexfield"{s} FAIL("Starting tag <indexfield> is not allowed here.");

<ROOT_indexfield,S_index,S_index_1,S_index_3,S_index_2>"<indexfield"{s} {
  AX_indexfield_name = 0;
  ENTER(AL_indexfield); pushbuffer(0);
  }

<AL_indexfield>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_indexfield_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_indexfield_name);

 ">" {
  if (!AX_indexfield_name) FAIL("Required attribute `name' not set for `indexfield' element.");
  LEAVE; STag_indexfield();pcdata_ix = 0; ENTER(E_indexfield);
 }
 "/>" {
  if (!AX_indexfield_name) FAIL("Required attribute `name' not set for `indexfield' element.");
  LEAVE; STag_indexfield(); pcdata_ix = 0; ETag_indexfield(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_index_1: case S_index_3: case S_index_2: SET(S_index_3); break;
   case ROOT_indexfield: SET(EPILOG); break;
   case S_index: SET(S_index_1); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of indexfield element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `indexfield' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `indexfield' element.");
}

<E_indexfield>{
 "</indexfield"{s}">" {
  LEAVE;
  ETag_indexfield();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_index_1: case S_index_3: case S_index_2: SET(S_index_3); break;
   case ROOT_indexfield: SET(EPILOG); break;
   case S_index: SET(S_index_1); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</indexfield>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</indexfield>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</indexfield>' expected.");
}

 /* <!-- Enumerated value 
  *      name
  *         Name of the enumerated value.
  *      value
  *         Value of the enumerated value in target-independent string format.
  * -->  */

 /*           name NMTOKEN #REQUIRED
  *           value CDATA #REQUIRED>  */

<E_relation,S_method_1,S_object,E_database,S_type_7,S_database,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_object_2,S_index,S_type_10,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_relation,E_index>"<value"{s} FAIL("Starting tag <value> is not allowed here.");

<ROOT_value,S_type_9,S_type_8,S_type_4,S_field,S_type_6,S_field_2,S_type,S_field_3,S_type_3,S_type_1>"<value"{s} {
  AX_value_name = 0;
  AX_value_value = 0;
  ENTER(AL_value); pushbuffer(0);
  }

<AL_value>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_value_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_value_name);

 "value"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_value_value);
 "value"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_value_value);

 ">" {
  if (!AX_value_name) FAIL("Required attribute `name' not set for `value' element.");
  if (!AX_value_value) FAIL("Required attribute `value' not set for `value' element.");
  LEAVE; STag_value();pcdata_ix = 0; ENTER(E_value);
 }
 "/>" {
  if (!AX_value_name) FAIL("Required attribute `name' not set for `value' element.");
  if (!AX_value_value) FAIL("Required attribute `value' not set for `value' element.");
  LEAVE; STag_value(); pcdata_ix = 0; ETag_value(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_field: case S_field_2: case S_field_3: SET(S_field_3); break;
   case ROOT_value: SET(EPILOG); break;
   case S_type_9: case S_type_8: case S_type_4: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_9); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of value element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `value' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `value' element.");
}

<E_value>{
 "</value"{s}">" {
  LEAVE;
  ETag_value();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_field: case S_field_2: case S_field_3: SET(S_field_3); break;
   case ROOT_value: SET(EPILOG); break;
   case S_type_9: case S_type_8: case S_type_4: case S_type_6: case S_type: case S_type_3: case S_type_1: SET(S_type_9); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</value>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</value>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</value>' expected.");
}

 /* <!-- Method of object or interface 
  *      name
  *         
  *         Name of the method.
  *      const
  *         If true, indicates that method cannot change object's data.
  *      
  *      returntype
  *         Type of the return value, can correspond to litesql's type names
  *         or target language type names.
  * -->  */

 /*           name NMTOKEN #REQUIRED
  *           const (true|false) "false"
  *           returntype CDATA #IMPLIED>  */

<E_relation,S_method_1,E_database,S_type_9,S_type_7,S_database,S_type_4,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_method_2,S_field_5,S_type_8,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<method"{s} FAIL("Starting tag <method> is not allowed here.");

<ROOT_method,S_interface,S_object_1,S_object,S_object_2,S_interface_2,S_interface_1>"<method"{s} {
  AX_method_name = 0;
  AX_method_const = A_method_const_false;
  AX_method_returntype = 0;
  ENTER(AL_method); pushbuffer(0);
  }

<AL_method>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_method_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_method_name);

 "const"{Eq}"'true'" |
 "const"{Eq}"\"true\"" A_method_const = A_method_const_true;
 "const"{Eq}"'false'" |
 "const"{Eq}"\"false\"" A_method_const = A_method_const_false;

 "returntype"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_method_returntype);
 "returntype"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_method_returntype);

 ">" {
  if (!AX_method_name) FAIL("Required attribute `name' not set for `method' element.");
  LEAVE; STag_method();pcdata_ix = 0; ENTER(S_method);
 }
 "/>" {
  if (!AX_method_name) FAIL("Required attribute `name' not set for `method' element.");
  LEAVE; STag_method(); pcdata_ix = 0; ETag_method(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_interface: case S_interface_2: case S_interface_1: SET(S_interface_2); break;
   case ROOT_method: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of method element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `method' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `method' element.");
}

<E_method,S_method_2,S_method>{
 "</method"{s}">" {
  LEAVE;
  ETag_method();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_interface: case S_interface_2: case S_interface_1: SET(S_interface_2); break;
   case ROOT_method: SET(EPILOG); break;
   case S_object_1: case S_object: case S_object_2: SET(S_object_2); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</method>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</method>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</method>' expected.");
}

 /* <!-- Parameter of method 
  *      Indicates that method requires a parameter.
  *     
  *      name
  *      
  *         Name of the parameter.
  *      type
  *         Type of the parameter, can correspond to litesql's type names
  *         or target language type names.
  * -->  */

 /*           name NMTOKEN #REQUIRED
  *           type CDATA #REQUIRED>  */

<E_relation,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,E_interface,S_field_1,S_database_2,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<param"{s} FAIL("Starting tag <param> is not allowed here.");

<ROOT_param,S_method_2,S_method_1,S_method>"<param"{s} {
  AX_param_name = 0;
  AX_param_type = 0;
  ENTER(AL_param); pushbuffer(0);
  }

<AL_param>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_param_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_param_name);

 "type"{Eq}\' ENTER(VALUE1); BUFFERSET(AX_param_type);
 "type"{Eq}\" ENTER(VALUE2); BUFFERSET(AX_param_type);

 ">" {
  if (!AX_param_name) FAIL("Required attribute `name' not set for `param' element.");
  if (!AX_param_type) FAIL("Required attribute `type' not set for `param' element.");
  LEAVE; STag_param();pcdata_ix = 0; ENTER(E_param);
 }
 "/>" {
  if (!AX_param_name) FAIL("Required attribute `name' not set for `param' element.");
  if (!AX_param_type) FAIL("Required attribute `type' not set for `param' element.");
  LEAVE; STag_param(); pcdata_ix = 0; ETag_param(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_method_2: case S_method_1: case S_method: SET(S_method_2); break;
   case ROOT_param: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of param element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `param' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `param' element.");
}

<E_param>{
 "</param"{s}">" {
  LEAVE;
  ETag_param();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_method_2: case S_method_1: case S_method: SET(S_method_2); break;
   case ROOT_param: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</param>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</param>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</param>' expected.");
}

 /* <!-- Relation between objects 
  *      Specifies a relation between objects. 
  *      Many-to-many relations and n-ary relations are implemented
  *      by storing links into a separate relation table.
  *      
  *      One-to-many and one-to-one relations are stored into object's table.
  *      Additional data can be added to the relation by using field-tags.
  *      
  *      Local options (applied only to relation's table if it has one)
  *      can be specified by using option-tags.
  *     
  *     name
  *         Relation can be referenced by this name after code generation.
  *         If no name is specified, it will be computed by concatenating
  *         the alphabetically ordered list of the objects' 
  *         (or interfaces') names and the id string of the relation.
  *     
  *     id
  *         Id string is used to differentiate relations with
  *         exactly same contents (same objects and interfaces).
  *         Id is appended to the name of the table.
  *    
  * -->  */

 /*           name NMTOKEN #IMPLIED
  *           id NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_relation_2,S_field_4,S_type_2,S_type_11,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_relation_1,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_relation,S_type_1,E_index>"<relation"{s} FAIL("Starting tag <relation> is not allowed here.");

<ROOT_relation,S_database_1,S_database,S_database_2>"<relation"{s} {
  AX_relation_name = 0;
  AX_relation_id = 0;
  ENTER(AL_relation); pushbuffer(0);
  }

<AL_relation>{
 "name"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_relation_name);
 "name"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_relation_name);

 "id"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_relation_id);
 "id"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_relation_id);

 ">" {
  LEAVE; STag_relation();pcdata_ix = 0; ENTER(S_relation);
 }
 "/>" {
  LEAVE; STag_relation(); pcdata_ix = 0; ETag_relation(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_relation: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of relation element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `relation' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `relation' element.");
}

<E_relation,S_relation_2,S_relation>{
 "</relation"{s}">" {
  LEAVE;
  ETag_relation();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_database_1: case S_database: case S_database_2: SET(S_database_2); break;
   case ROOT_relation: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</relation>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</relation>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</relation>' expected.");
}

 /* <!-- Participation in relation 
  *      Specifies an interface or a class which participates in relation.
  *     unique
  *         
  *          If true, there can be only one link to related object.
  *      limit
  *         
  *          Similar to unique, only applicable to binary relations.
  *          If set to 'one', sets an uniqueness constraint to the other object.
  *      object
  *          The object that participates in the relation.
  *      
  *      interface
  *          Objects that implement the interface will participate in the
  *          relation. Only one interface may be included in a relation.
  *      handle
  *          Defines "a handle" for the relation. The handle represents
  *          a view to the relation from a single object's point of view.
  *          Can not be used if an interface is included in the relation
  *          because the handle would possibly point to multiple types
  *          of objects. 
  * -->  */

 /*           unique (true|false) "false"
  *           limit (one|many) "many"
  *           object IDREF #IMPLIED
  *           interface IDREF #IMPLIED
  *           handle NMTOKEN #IMPLIED>  */

<E_relation,S_method_1,S_object,E_database,S_type_9,S_type_7,S_database,S_type_4,S_interface_2,S_index_1,S_index_3,E_method,E_field,S_field_2,S_type,S_field_3,S_field_4,S_type_2,S_type_11,S_database_1,S_type_5,S_interface,S_object_1,S_method_2,S_field_5,S_type_8,S_object_2,S_index,S_field,S_type_10,S_type_6,S_method,E_interface,S_field_1,S_database_2,E_type,E_object,S_interface_1,S_index_2,S_type_3,S_type_1,E_index>"<relate"{s} FAIL("Starting tag <relate> is not allowed here.");

<ROOT_relate,S_relation_1,S_relation_2,S_relation>"<relate"{s} {
  AX_relate_unique = A_relate_unique_false;
  AX_relate_limit = A_relate_limit_many;
  AX_relate_object = 0;
  AX_relate_interface = 0;
  AX_relate_handle = 0;
  ENTER(AL_relate); pushbuffer(0);
  }

<AL_relate>{
 "unique"{Eq}"'true'" |
 "unique"{Eq}"\"true\"" A_relate_unique = A_relate_unique_true;
 "unique"{Eq}"'false'" |
 "unique"{Eq}"\"false\"" A_relate_unique = A_relate_unique_false;

 "limit"{Eq}"'one'" |
 "limit"{Eq}"\"one\"" A_relate_limit = A_relate_limit_one;
 "limit"{Eq}"'many'" |
 "limit"{Eq}"\"many\"" A_relate_limit = A_relate_limit_many;

 "object"{Eq}'{Name}' BUFFERLITERAL('\'',AX_relate_object);
 "object"{Eq}\"{Name}\" BUFFERLITERAL('"',AX_relate_object);

 "interface"{Eq}'{Name}' BUFFERLITERAL('\'',AX_relate_interface);
 "interface"{Eq}\"{Name}\" BUFFERLITERAL('"',AX_relate_interface);

 "handle"{Eq}'{Nmtoken}' BUFFERLITERAL('\'',AX_relate_handle);
 "handle"{Eq}\"{Nmtoken}\" BUFFERLITERAL('"',AX_relate_handle);

 ">" {
  LEAVE; STag_relate();pcdata_ix = 0; ENTER(E_relate);
 }
 "/>" {
  LEAVE; STag_relate(); pcdata_ix = 0; ETag_relate(); popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case ROOT_relate: SET(EPILOG); break;
  }
 }
 .       FAIL("Unexpected character `%c' in attribute list of relate element.", yytext[0]);
 {Name} FAIL("Bad attribute `%s' in `relate' element start tag.",yytext);
 <<EOF>> FAIL("EOF in attribute list of `relate' element.");
}

<E_relate>{
 "</relate"{s}">" {
  LEAVE;
  ETag_relate();
  popbuffer(); /* attribute */
  switch (YY_START) {
   case S_relation_1: case S_relation_2: case S_relation: SET(S_relation_2); break;
   case ROOT_relate: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" FAIL("Unexpected end-tag `%s': `</relate>' expected.",yytext);
 .       FAIL("Unexpected character `%c': `</relate>' expected.",yytext[0]);
 <<EOF>> FAIL("Premature EOF: `</relate>' expected.");
}

 /* EPILOG: after the root element. */

<EPILOG>{
 . {SET(PROLOG); yyless(0); CLEANUP; return -1;}
 <<EOF>>  { if (xml::posStack.empty()) { SUCCEED; } else FAIL("Premature </database>."); };
}

 /* CHARACTER DATA. */

<IMPOSSIBLE,VALUE1,VALUE2>{
 /* Non-defined standard entities... */
"&amp;"  BUFFERPUTC('&');
"&lt;"   BUFFERPUTC('<');
"&gt;"   BUFFERPUTC('>');
"&apos;" BUFFERPUTC('\'');
"&quot;" BUFFERPUTC('"');

 /* Character entities. */
 "&#"[[:digit:]]+";"	BUFFERPUTC((unsigned char)atoi(yytext+2));
 "&#x"[[:xdigit:]]+";"	BUFFERPUTC((unsigned char)strtol(yytext+3,NULL,16));
}

<IMPOSSIBLE,VALUE1,VALUE2,CDATA>{
 "\n"		|
 "\r"		|
 "\r\n"		|
 "\n\r"		BUFFERPUTC('\n');
}

<IMPOSSIBLE>{
 "<![CDATA["	ENTER(CDATA);
 "]""]>"		FAIL("Unexpected `]""]>' in character data.");
}

<VALUE1>{
 \'		BUFFERDONE; LEAVE;
 <<EOF>>	FAIL("EOF in literal (\"'\" expected).");
}

<VALUE2>{
 \"		BUFFERDONE; LEAVE;
 <<EOF>>	FAIL("EOF in literal (`\"' expected).");
}

<IMPOSSIBLE,VALUE1,VALUE2>{
 [^<&]		BUFFERPUTC(yytext[0]);
 [<&]		FAIL("Spurious `%c' in character data.",yytext[0]);
}

<CDATA>{
 "]""]>"		LEAVE;
 /* "]""]"		BUFFERPUTC(yytext[0]); BUFFERPUTC(yytext[1]); */
 .		BUFFERPUTC(yytext[0]);
 <<EOF>>	FAIL("EOF in CDATA section.");
}

 /* Impossible rules to avoid warnings from flex(1). */
 /* Ideally, this should be replaced by code in flexml.pl that
    generates just the states not covered by other rules. */
<*>{
 .|[\n] FAIL("Syntax error on character `%c'.", yytext[0]);
}

%%

/* Element context stack lookup. */
int element_context(int i)
{
  return (0<i && i<yy_start_stack_depth
	  ? yy_start_stack[yy_start_stack_ptr - i]
	  : 0);
}

#ifdef FLEX_DEBUG
void print_yy_stack(char* fmt, ...)
{
  int i = 0; va_list ap; va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  if (statenames) {
      for (i=1; i<yy_start_stack_ptr; i++) {
          fprintf(stderr, "%s/", statenames[yy_start_stack[i] ]);
      }
      fprintf(stderr,"%s\n", statenames[YY_START]);
  }
  va_end(ap);
}

void print_bufferstack()
{
    int i;
    fputs("Buffer: ", stderr);
    for (i = 0; i < blimit; i++) {
       if ( bufferstack[i] == '\377' ) break;
         putc(bufferstack[i], stderr);
    }
    putc('\n', stderr);
}

static void debug_enter(int state, const char* statename) {
  yy_push_state(state);
  if (yy_flex_debug) {
       print_yy_stack("--ENTER(%s) : ",statename);
       print_bufferstack();
  }
}

static void debug_leave(void) {
    if (yy_flex_debug) {
        print_yy_stack("--LEAVE : ");
	print_bufferstack();
    }
  yy_pop_state();
}

static void debug_set(int state, const char* statename) {
  BEGIN(state);
  if (yy_flex_debug) print_yy_stack("--SET(%s) : ",statename);
}
#endif


static void cleanup(void)
{
    if (statenames) {
        free(statenames);
	statenames = NULL;
    }
    free(bufferstack);
    bufferstack = NULL;

    free(indexstack);
    indexstack = NULL;
}


static int fail(const char* fmt, ...)
{
    int chars_left, used;
    va_list ap; va_start(ap, fmt);
#ifdef FLEXML_yylineno
    used = sprintf(flexml_err_msg,
		   "Invalid XML (XML input line %d, state %d, file \"%s\"): ",
		   yylineno, YY_START, xml::currentFile.c_str());
#else
    used = sprintf(flexml_err_msg,
		   "Invalid XML (state %d, file \"%s\"): ",
		   YY_START, xml::currentFile.c_str());
#endif
    chars_left = flexml_max_err_msg_size - used - 1;
    vsnprintf(flexml_err_msg + used, chars_left, fmt, ap);
    va_end(ap);

#ifndef FLEXML_quiet_parser
    /* print directly to sdterr */
    fprintf(stderr, "%s\n", flexml_err_msg);
    flexml_err_msg[0] = '\0';
#endif

    cleanup();

    return 1;
}
